###컴퓨터 구조

	1. CPU : 중앙처리장치
		1) ALU(Arithmetic Logic Unit) : 산술연산, 논리 연산
		2) Control Unit : 명령어를 해석하고 해석된 결과에 따라 적절한 신호를 CPU다른 블록에 보냄
		3) Register Set : CPU내에 있는 작은 메모리, 2진 데이터를 저장하기 위한 저장장치
		4) Bus Interface : CPU 내부에 데이터를 전달, 입력 을 담당하는 통신장치
		5) Clock Pulse : 타이밍, 동기화를 제공
	2. 메인메모리 : Ram 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역
	3. 입출력버스 : 컴퓨터 구성요소 사이에서 데이터를 주고 받기 위해 사용되는 경로
		1) Data Bus : 데이터(명령어, 피연산자 등) 이동에 필요한 버스
		2) Address Bus : 주소값 이동 및 읽기 
		3) Control Bus : CPU가 어떤 작업을 할지 메모리에 전달 

###프로그램의 실행과정

	1. 빌드
		1) 전처리기 치환작업
		2) 컴파일러에 의한 어셈블리 번역
		3) 어셈블러에 의한 바이너리 코드 생성
		4) 링커에 의한 연결과 결합(참조하는 함수, 라이브러리 등을 하나루 묶는작업)
	
	2. 실행
		1) Fetch : 메모리상에 존재하는 명령어를 CPU로 가져오는 작업(Register Set:IR에 저장)
		2) Decode : 가져다 놓은 명령어를 CPU가 해석하는 단계(Control Unit에서 담당)
		3) Execution : 해석된 대로 CPU가 실행하는 단계(ALU 담당)


###Win32 Vs Win64

	한번에 송수신 할 수 있는 데이터 크기와 한번에 처리할 수 있는 데이터 크기(32bit, 64Bit)를 기준으로 구분
	2의 32승 -> 4G

###Process 구성요소

	1) Data 영역 : 전역변수, static변수
	2) Stack 영역 : 지역변수, 함수 호출시 전달되는 인자값들의 저장
	3) Heap 영역 : 동적 할당
	4) Code 영역 : 실행파일을 구성하는 명령어들이 올라가는 메모리 영역
	 + Register Set : 현재 실행중인 프로그램을 위한 데이터들로 채워짐
		 
###커널 오브젝트의 이해

	1) 커널 
	   컴퓨터를 운영하느데 있어서 중심이 되는 운영체제 핵심 부분
	2) 커널 오브젝트 
	   커널에서 관리하는 중요한 정보(프로세스, 쓰레드, 파일 리소스)를 담아둔 데이터 블록을 뜻한다.
	   프로세스가 생성 될 때 마다 프로세스 관리 구조체 변수가 하나씩 생성되고 해당 프로세스 정보로 초기화된다.

###커널 오브젝트의 상태

	Signaled(신호를 받은 상태) <-> Non-Signaled(신호를 받지 않은 상태) 로 변환
	프로세스의 커널 오브젝트는 생성과 동시에 Non-Signaled가 되고 종료되면 Signaled가 된다.
	WaitForSingleObject함수는 Non-Signaled면 블로킹 되고 Signaled되면 통과한다.

###프로세스간 통신(IPC) 

	Inter Process Communication의 약자
	통신의 종류
		1) 메일 슬롯(Mail Slot) 방식
			한 방향으로만 메시지의 전달이 가능하다
			브로드캐스팅 방식의 통신을 지원하기 때문에 관계없는 프로세스들 사이에서도 통신이 가능
		2) 이름 있는 파이프(Named Pipe) 방식
			메일 슬롯과 유사 하지만 브로드캐스트 방식을 지원하기 않고 양방향 통신을 지원
		3) 이름 없는 파이프(Anonymous Pipe) 방식
			단방향 통신방식을 취하며, 파이프를 통해서 생성된 핸들을 기반으로 통신하기 때문에 프로세스들 사이에 관계가 있어야 한다.

###스케쥴링 알고리즘과 우선순위

	1) 비선점형(None Preemtive) OS	
		과거 Windows3.x 시리즈
		현재 실행중인 프로세스보다 높은 우선순위의 프로세스가 등장한다고해서 실행의 대상을 변경하지 않는다.
		다른 프로세스의 실행을 위해서는 현재 실행중인 프로세스가 명시적으로 CPU 양보 또는 블로킹상태에 놓일때까지 기다려야한다.

	2) 선점형(Preemptive) OS
		오늘날 모든 OS들의 방식
		우선순위에 따라 프로세스 실행이 결정된다. 
		스케쥴러에 의한 실행순서 조정이 적극 가해진다.
		멀티프로세스 기반 OS에 적합하다.

	3) 우선순위
		6단계의 우선순위 계층을 제공
		숫자가 높을수록 높은 우선순위를 가진다.

	4) 라운드 로빈(Round-Robin) 스케줄링 알고리즘
		프로세스의 우선순위가 동일할 때 적용되는 알고리즘
		정해진 시간 간격만큼만 실행을하고 우선순위가 동일한 다른 프로세스에게 CPu의 할당을 넘기는 방식을 제공

###스택 프레임 구조	

	1) sp(Stack pointer) 레지스터 
	   스택에 데이터를 쌓거나 반환하기 위해서 현재 어느 위치까지 데이터를 저장했는지 기억하는 레지스터
	2) fp(Frame Pointer) 레지스터 
	   함수 반환 후 원래 위치로 돌아가기 위해 함수 호출 이전의 sp 위치를 저장하는 레지스터
	   함수 중첩에 따른 문제를 해결하기 위해서 sp레지스터의 값을 fp로 옮기기전에 fp 레지스터 값을 스택에 쌓아두어 수정
	3) pc(Program Counter) : 실행해야 할 명령어가 있는 위치를 가리킨다. 

###함수 호출 규약(Calling Convention)

	32Bit
		1) __cdecl : C/C++의 디폴트 호출규약 오른쪽에 전달되는 인자가 먼저 스택에 쌓이는 방식. 
					 반환시에는 함수를 호출하는 호출자가 스택프레임을 반환한다.
		2) __stdcall : 호출된 함수 내에서 스택프레임을 반환한다.
		3) __fastcall : 함수 호출을 빠르게 처리하기 위한 호출규약 호출 인자 2개까지는 레지스터에 저장하고 그 이후는 스택에 저장
		
###Thread

	하나의 프로그램 내에서 여러개의 실행 흐름을 두기 위한 모델이다
	프로세스 처럼 완벽히 독립적인 구조가 아니다. 쓰레드들 사이에는 공유하는 요소들이 있다.
	공유하는 요소가 있는 관계로 컨텍스트 스위칭에 걸리는 시간이 프로세스보다 짧다.

	Code, Data, Heap영역을 공유한다. 
	Stack은 쓰레드 마다 독립적으로 할당한다. (실행 흐름의 추가를 위한 최소 조건이 독립된 스택의 제공)

	User 영역 : Code, Data, Heap, Stack
	Kernel 영역 : 하나의  프로세스에게 할당된 총 메모리 공간중에서 유저 영역을 제외한 나머지 영역 
				  즉, 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간	 
			
###Thread동기화

	1) 유저 모드 동기화 
		커널의 힘을 빌리지 않는 동기화 기법이다. 
		커널모드로의 전환이 불필요하기 때문에 성능에 이점이 있지만 기능상의 제약이 있다.

	2) 커널 모드 동기화
		커널에서 제공하는 동기화 기능을 활용하는 방법이다. 
		따라서 동기화 관련된 함수가 호출될 때마다 커널 모드로의 변경이 필요하고 이는 성능 저하로 이어진다.

###메모리 접근에 따른 동기화

	 Critical Section
		특정 코드에 둘이상의 쓰레드가 동시에 접근 실행을 할경우 문제를 일으키는 코드 블록
		한 순간에 하나의 쓰레드만 접근이 요구되는 공유 리소스에 접근하는 코드 블록

		Critical Section 종류
			1. 유저 모드 동기화
				1) Critical Section : 메모리 접근 동기화
					상가건물 화장실 열쇠처럼 열쇠를 획득해야만 접근가능한 방식
				2) Interlocked Family of Function : 메모리 접근 동기화
					코드 블럭이 아닌 변수 하나의 접근방식을 동기화하는 것이 목적
					원자적 접근(Atomic Acees) 한순간에 하나의 쓰레드만 접근하는것을 보장하는 함수
			2. 커널 모드 동기화
				1) Mutext : 메모리 접근 동기화
					커널 오브젝트로 생성한다. 
					크리티컬섹션과 달리 초기화 함수가 필요없다. 
					Signaled상태 일때 WaitForSingleObject 함수로 뮤텍스 획득이 하면서 Non-Signaled가 된다.
				2) Semaphore : 메모리 접근 동기화
					접근가능 쓰레드 수 설정이 가능한 Mutext라고 보면됨
					WaitForSingleObject 함수를 호출 할 때마다 카운트가 줄어들고 0개가 되면 Non-Signaled가 된다. 
				3) Named Mutex,	Named Semaphore : 프로세스간 동기화					
					별로 안중요함...
				4) Event : 실행순서 동기화
					Signaled, Non-Signaled를 직접 프로그래머 요청에 의해 변경한다.
					수동 리셋 모드, 자동 리셋 모드에 따라 상태가 결정된다.
				5) Timer 기반 동기화					
					설정한 시간이 되면 Signaled가 됨에 따라 동기화 시킨다.

	※ volatile 키워드
		1) 최적화를 하지마라
		2) 메모리에 직접 연산해라(캐쉬되지 않기 때문에 레지스터에 할당되지 않는다)

###Thread Pool

	한번 생성한 쓰레드를 재활용하여 시스템의 부담을 덜어주기 위한 기법
	쓰레드는 생성과 소멸에 소모되는 리소스가 상당하기 때문에 등장

###메모리 계층 구조

	CPU에서 가까운 순서대로 레지스터->캐쉬->메인메모리->하드디스크
	프로그램이 실행되는 동안에는 하드디스크를 제외하고 모든 메모리는 항상 채워져있다.

###가상 메모리	

	1. MMU(Memory Management Unit) : MMU를 통해서 CPU가 가상 용량이 있다고 믿게 만든다.
	2. 페이지 프레임(Page Frame) : 블럭의 크기를 하드웨어 입장에서 부르는말이며 실제 메인 메모리 블럭을 나타낸다.
	3. 페이지(Page) : 블럭의 크기를 소프트웨어 입장에서 부르는말이며 가상 메모리 블럭을 나타낸다.	
	4. 페이지의 키는 페이지 숫자이며 값은 해당 페이지가 존재하는 페이지 프레임의 시작 번지를 나타낸다.
	   ※ 페이지의 개수 = 가상 메모리의 크기 / 페이지 하나당 크기
 	5. 페이지의 할당 상태
		1) Reserve : Commit을 예상하고 미리 공간을 예약하여 다른 메모리 
					 할당 함수에 의해 해당 페이지가 할당되지 않도록 막는 상태
		2) Commit : 물리 메모리에 할당이 이뤄진 페이지
		3) Free : 물리메모리에 할당이 되지 않은 페이지
		4) VirtualAlloc & VirtualFree를 통해 상태를 변경한다.

###메모리 관리

	1. Default Heap == Process Heap
		프로세스가 생성 될때 자동으로 Reserve상태로 생성되는 힙 영역
		할당한 Heap영역이 기본으로 설정된 크기보다 커지면 윈도우 시스템이 알아서 heap영역을 늘려준다.
		다만 시작시점에서 힙영역을 여유롭게 잡아두면 그만큼 추가 할당에 따르는 시간을 아낄수 있지만
		메모리 단편화로 인해 속도 저하(캐시미스)가 될수도 있다. 왜냐하면 디폴트 힙 공간 안에서 
		무작위 메모리 할당 및 힙크기의 증가가 이뤄지기 때문이다.
		쓰레드에서는 디폴트 힙에 메모리를 할당할 때 내부적으로 동기화 처리를 하기 때문에 속도 저하가 생길수 있다.  

	2. Dynamic Heap
		윈도우 시스템 함수를 호출을 통해 분리 생성되는 Reserve 힙 영역
		생성된 Heap공간 마다 할당한 크기만큼 분리되기 때문에 복잡하지 않게 특정 용도로만 사용할 경우 단편화가 발생하지 않는다.
		쓰레드마다 힙을 분리하면 동기화 처리가 필요없기 때문에 성능 향상이 가능하며 구현의 용이성도 좋아진다.

	3. MMF(Memory Mapped File)
		파일의 일부 영역을 가상메모리 일부에 연결시키는 메커니즘
		가상메모리와 파일 영역이 연결되어 있기때문에 메모리에 저장시키면 파일에도 동일하게 저장된다

		장점 
		- 프로그래밍 하기가 편하다. // 메모리 조작만으로도 파일도 함께 수정되기 때문에 파일 읽기/쓰기 과정이 필요없다.
		- 성능 향상 // 메모리가 파일 데이터의 캐쉬 역활을 하기 떄문에 직접 파일에 접근하는것 보다 효율적인 접근이 가능하다 
		              또한 특정 상황마다 주기적으로 파일에 저장된다.
	
	4. COW(Copy On Write)
		멀티 쓰레드 기반 최적화 기법
		쓰레드마다 동일한 테이블값을 복사하여 관리할 때 만약 참조만 한다면 따로 복사하지않고 동일한 값을 가져다 참조만 하다가
		특정 값이 특정 쓰레드에서 다른 값을 변경되었을 시점에서 테이블을 복사하여 분리 관리하도록 하는 기법



###Dynamic Linking Library

	1. Static Library
		라이브러리가 실행파일에 포함된다. Lib로 출력 되어 나오며 포함하고자 하는 프로그램 코드에 
		#pragma comment(lib, "포함할라이브러리이름.lib")를 추가하거나 속성 탭의 Additional Dependencies에 포함하면 된다.
		Static Library의 장점은 실행의 독립성이다 실행 파일만으로도 실행이 가능하다. 
		lib가 이미 포함되어있으니 따로 관리하지 않아도 된다. 	다만 같은 라이브러리를 Static하게 사용하는 
		여러개의 프로그램에서 동일한 라이브러리 내용은 각각 따로 메모리 공간을 차지하게 되는 단점이 있다.

	2. DLL
		실행파일의 일부로 포함되지않고 독립적으로 저장되는 라이브러리이다. 
		실행파일을 실행하게 되면 파일은 exe와 dll로 독립적이지만 dll을 사용하기 위해 가상메모리 주소에 dll을 매핑해야 
		dll 함수를 호출할 수 있다. 장점은 둘이상의 프로세스가 동일한 dll을 공유하는 경우 
		메인 메모리에서 페이지 단위로 공유가 이뤄진다. 
		1) 암시적 연결(Implicit Linking)
			빌드 결과가 Lib와 Dll로 나온다. 여기서 lib는 dll이 제공하고자 하는 함수정보를 지닌다. 
			즉, lib는 빌드(링크)할때 필요하고 dll은 실행할때 필요하다. 
			여기서 lib는 정적 라이브러리의 lib와는 성격이 다르지만 어째든 빌드할 때 포함시켜야한다. 
			
			암시적 연결 장점
				- 코드가 간결해진다. 
				- 사용하기 쉽다
		
		2) 명시적 연결(Explicit Linking)
			소스 코드 내에 Dll 연결 코드가 명시적으로 있다면 명시적 연결방법 이다. 또한 Lib가 필요없다. 
			LoadLibrary와 GetProcAddress를 통해서 사용할 함수 포인터를 획득하며 FreeLibray로 dll을 반환한다. 
			Dll을 참조하는 프로세스가 하나도 존재하지 않을 시점이 되어야 물리모메리에서 실질적으로 dll이 반환된다.
			
			명시적 연결의 장점
				- dll이 필요한시점에서 로딩되고 불필요하면 반환이 가능
				- 프로그램 실행 중에 dll교체 및 선택이 가능
				- 필요한 시점에 로드하기 때문에 프로그램의 실행까지 걸리는 시간이 짧고 로딩 시간 분산이 가능하다. 
		
	3. 한번이상 로드될수 있는 dll
		1) A.exe가 실행될 때 x.dll을 로드하여 메모리에 올라간다(물리메모리에 할당)
		2) B.exe가 실행될 때 x.dll을 로드하면 이미 물리 메모리에 올라가있기 때문에 B.exe가상메모리영역과 
		   연결 매핑(Memory Mapping)만 한다.
		3) A.exe가 종료되어도 B.exe가 남아있기 때문에 물리메모리에는 x.dll이 남아있다.
		4) B.exe가 종료되면 x.dll을 참조하는 프로세스가 하나도 없기 때문에 이시점에서 dll이 물리메모리에서 반환된다.
		
		※ dll을 빌드 할 때 dll이 할당 되어야 할 가상메모리 주소를 링커가 결정한다. 
		   특정 가상 주소를 지정하면 그 주소에 dll을 매핑하는데  A.exe가 x.dll을 로드 한후 
		   B.exe가 x.dll이 할당될 가상메모리 주소에 다른 내용을 할당하면 x.dll은 다른 주소로 옮겨서 다시 매핑되기 때문에 
		   물리메모리에 2개이상 올라갈 가능성이 있다
